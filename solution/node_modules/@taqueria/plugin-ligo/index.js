var $kQNfl$taquerianodesdk = require("@taqueria/node-sdk");
var $kQNfl$fspromises = require("fs/promises");
var $kQNfl$path = require("path");




const $9d8c61104c8e60ad$export$1336661d942c7074 = `
type storage = int

type parameter =
  Increment of int
| Decrement of int
| Reset

type return = operation list * storage

// Two entrypoints

let add (store, delta : storage * int) : storage = store + delta
let sub (store, delta : storage * int) : storage = store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
let main (action, store : parameter * storage) : return =
 ([] : operation list),    // No operations
 (match action with
   Increment (n) -> add (store, n)
 | Decrement (n) -> sub (store, n)
 | Reset         -> 0)
`;
const $9d8c61104c8e60ad$export$ec41334b92330d9b = `
type storage is int

type parameter is
  Increment of int
| Decrement of int
| Reset

type return is list (operation) * storage

// Two entrypoints

function add (const store : storage; const delta : int) : storage is 
  store + delta

function sub (const store : storage; const delta : int) : storage is 
  store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
function main (const action : parameter; const store : storage) : return is
 ((nil : list (operation)),    // No operations
  case action of [
    Increment (n) -> add (store, n)
  | Decrement (n) -> sub (store, n)
  | Reset         -> 0
  ])
`;
const $9d8c61104c8e60ad$export$9e59f1f7960689be = `
type storage = int;

type parameter =
  Increment (int)
| Decrement (int)
| Reset;

type return = (list (operation), storage);

// Two entrypoints

let add = ((store, delta) : (storage, int)) : storage => store + delta;
let sub = ((store, delta) : (storage, int)) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
   
let main = ((action, store) : (parameter, storage)) : return => {
 (([] : list (operation)),    // No operations
 (switch (action) {
  | Increment (n) => add ((store, n))
  | Decrement (n) => sub ((store, n))
  | Reset         => 0}))
};
`;
const $9d8c61104c8e60ad$export$6d35abb7f92d1079 = `
type storage = int;

type parameter =
  ["Increment", int]
| ["Decrement", int]
| ["Reset"];

type ret = [list<operation>, storage];

// Two entrypoints

const add = ([store, delta] : [storage, int]) : storage => store + delta;
const sub = ([store, delta] : [storage, int]) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */

const main = ([action, store] : [parameter, storage]) : ret => {
 return [list([]) as list<operation>,    // No operations
 match (action, {
  Increment:(n: int) => add ([store, n]),
  Decrement:(n: int) => sub ([store, n]),
  Reset    :()  => 0})]
};
`;


const $40622e3a438d0515$var$registerContract = (arg, contractName)=>{
    (0, $kQNfl$taquerianodesdk.experimental).registerContract(arg, contractName);
};
const $40622e3a438d0515$var$getLigoTemplate = async (contractName, syntax)=>{
    const matchResult = contractName.match(/\.[^.]+$/);
    const ext = matchResult ? matchResult[0].substring(1) : null;
    if (syntax === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
    if (syntax === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
    if (syntax === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
    if (syntax === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
    if (syntax === undefined) {
        if (ext === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
        if (ext === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
        if (ext === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
        if (ext === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
        return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`);
    } else return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
};
const $40622e3a438d0515$var$createContract = (arg)=>{
    const contractName = arg.sourceFileName;
    const syntax = arg.syntax;
    const contractsDir = `${arg.config.projectDir}/${arg.config.contractsDir}`;
    return $40622e3a438d0515$var$getLigoTemplate(contractName, syntax).then((ligo_template)=>(0, $kQNfl$fspromises.writeFile)(`${contractsDir}/${contractName}`, ligo_template)).then((_)=>$40622e3a438d0515$var$registerContract(arg, contractName));
};
var $40622e3a438d0515$export$2e2bcd8739ae039 = $40622e3a438d0515$var$createContract;





// Should point to the latest stable version, so it needs to be updated as part of our release process.
const $844cb58d66fbf6db$var$LIGO_DEFAULT_IMAGE = "ligolang/ligo:0.54.1";
const $844cb58d66fbf6db$var$LIGO_IMAGE_ENV_VAR = "TAQ_LIGO_IMAGE";
const $844cb58d66fbf6db$export$2b403d61ac8ea302 = ()=>(0, $kQNfl$taquerianodesdk.getDockerImage)($844cb58d66fbf6db$var$LIGO_DEFAULT_IMAGE, $844cb58d66fbf6db$var$LIGO_IMAGE_ENV_VAR);
const $844cb58d66fbf6db$export$17f107107c3c82c6 = (parsedArgs, sourceFile)=>(0, $kQNfl$path.join)(parsedArgs.config.contractsDir, sourceFile);
const $844cb58d66fbf6db$export$b59ff90dc389ce6d = (err, sourceFile)=>{
    (0, $kQNfl$taquerianodesdk.sendErr)(`\n=== For ${sourceFile} ===`);
    err instanceof Error ? (0, $kQNfl$taquerianodesdk.sendErr)(err.message.replace(/Command failed.+?\n/, "")) : (0, $kQNfl$taquerianodesdk.sendErr)(err);
};






const $24b2f47d8f306cb3$var$COMPILE_ERR_MSG = "Not compiled";
const $24b2f47d8f306cb3$var$isStorageKind = (exprKind)=>exprKind === "storage" || exprKind === "default_storage";
const $24b2f47d8f306cb3$var$isLIGOFile = (sourceFile)=>/.+\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isStorageListFile = (sourceFile)=>/.+\.(storageList|storages)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isParameterListFile = (sourceFile)=>/.+\.(parameterList|parameters)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
const $24b2f47d8f306cb3$var$isContractFile = (sourceFile)=>$24b2f47d8f306cb3$var$isLIGOFile(sourceFile) && !$24b2f47d8f306cb3$var$isStorageListFile(sourceFile) && !$24b2f47d8f306cb3$var$isParameterListFile(sourceFile);
const $24b2f47d8f306cb3$var$extractExt = (path)=>{
    const matchResult = path.match(/\.(ligo|religo|mligo|jsligo)$/);
    return matchResult ? matchResult[0] : "";
};
const $24b2f47d8f306cb3$var$removeExt = (path)=>{
    const extRegex = new RegExp($24b2f47d8f306cb3$var$extractExt(path));
    return path.replace(extRegex, "");
};
const $24b2f47d8f306cb3$var$getOutputFilename = (parsedArgs, sourceFile)=>{
    const outputFile = (0, $kQNfl$path.basename)(sourceFile, (0, $kQNfl$path.extname)(sourceFile));
    return (0, $kQNfl$path.join)(parsedArgs.config.artifactsDir, `${outputFile}.tz`);
};
// Get the contract name that the storage/parameter file is associated with
// e.g. If sourceFile is token.storageList.mligo, then it'll return token.mligo
const $24b2f47d8f306cb3$var$getContractNameForExpr = (sourceFile, exprKind)=>{
    try {
        return $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? sourceFile.match(/.+(?=\.(?:storageList|storages)\.(ligo|religo|mligo|jsligo))/).join(".") : sourceFile.match(/.+(?=\.(?:parameterList|parameters)\.(ligo|religo|mligo|jsligo))/).join(".");
    } catch (err) {
        throw new Error(`Something went wrong internally when dealing with filename format: ${err}`);
    }
};
// If sourceFile is token.storageList.mligo, then it'll return token.storage.{storageName}.tz
const $24b2f47d8f306cb3$var$getOutputExprFileName = (parsedArgs, sourceFile, exprKind, exprName)=>{
    const contractName = (0, $kQNfl$path.basename)($24b2f47d8f306cb3$var$getContractNameForExpr(sourceFile, exprKind), (0, $kQNfl$path.extname)(sourceFile));
    const outputFile = exprKind === "default_storage" ? `${contractName}.default_storage.tz` : `${contractName}.${exprKind}.${exprName}.tz`;
    return (0, $kQNfl$path.join)(parsedArgs.config.artifactsDir, `${outputFile}`);
};
const $24b2f47d8f306cb3$var$getCompileContractCmd = (parsedArgs, sourceFile)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$2b403d61ac8ea302)()} compile contract`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const outputFile = `-o ${$24b2f47d8f306cb3$var$getOutputFilename(parsedArgs, sourceFile)}`;
    const cmd = `${baseCmd} ${inputFile} ${outputFile}`;
    return cmd;
};
const $24b2f47d8f306cb3$var$getCompileExprCmd = (parsedArgs, sourceFile, exprKind, exprName)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const compilerType = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storage" : "parameter";
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$2b403d61ac8ea302)()} compile ${compilerType}`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const outputFile = `-o ${$24b2f47d8f306cb3$var$getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName)}`;
    const cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile}`;
    return cmd;
};
const $24b2f47d8f306cb3$var$compileContract = (parsedArgs, sourceFile)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$24b2f47d8f306cb3$var$getCompileContractCmd(parsedArgs, sourceFile)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stderr: stderr  })=>{
        if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
        return {
            contract: sourceFile,
            artifact: $24b2f47d8f306cb3$var$getOutputFilename(parsedArgs, sourceFile)
        };
    }).catch((err)=>{
        (0, $844cb58d66fbf6db$export$b59ff90dc389ce6d)(err, sourceFile);
        return {
            contract: sourceFile,
            artifact: $24b2f47d8f306cb3$var$COMPILE_ERR_MSG
        };
    });
const $24b2f47d8f306cb3$var$compileExpr = (parsedArgs, sourceFile, exprKind)=>(exprName)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$24b2f47d8f306cb3$var$getCompileExprCmd(parsedArgs, sourceFile, exprKind, exprName)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stderr: stderr  })=>{
            if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
            return {
                contract: sourceFile,
                artifact: $24b2f47d8f306cb3$var$getOutputExprFileName(parsedArgs, sourceFile, exprKind, exprName)
            };
        }).catch((err)=>{
            (0, $844cb58d66fbf6db$export$b59ff90dc389ce6d)(err, sourceFile);
            return {
                contract: sourceFile,
                artifact: $24b2f47d8f306cb3$var$COMPILE_ERR_MSG
            };
        });
const $24b2f47d8f306cb3$var$compileExprs = (parsedArgs, sourceFile, exprKind)=>(0, $kQNfl$fspromises.readFile)((0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile), "utf8").then((data)=>data.match(/(?<=\n\s*(let|const)\s+)[a-zA-Z0-9_]+/g)).then((exprNames)=>{
        if (!exprNames) return [];
        const firstExprName = exprNames.slice(0, 1)[0];
        const restExprNames = exprNames.slice(1, exprNames.length);
        const firstExprKind = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "default_storage" : "parameter";
        const restExprKind = $24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storage" : "parameter";
        const firstExprResult = $24b2f47d8f306cb3$var$compileExpr(parsedArgs, sourceFile, firstExprKind)(firstExprName);
        const restExprResults = restExprNames.map($24b2f47d8f306cb3$var$compileExpr(parsedArgs, sourceFile, restExprKind));
        return Promise.all([
            firstExprResult
        ].concat(restExprResults));
    }).catch((err)=>{
        (0, $844cb58d66fbf6db$export$b59ff90dc389ce6d)(err, sourceFile);
        return [
            {
                contract: sourceFile,
                artifact: `No ${$24b2f47d8f306cb3$var$isStorageKind(exprKind) ? "storage" : "parameter"} values compiled`
            }
        ];
    }).then($24b2f47d8f306cb3$var$mergeArtifactsOutput(sourceFile));
// TODO: Just for backwards compatibility. Can be deleted in the future.
const $24b2f47d8f306cb3$var$tryLegacyStorageNamingConvention = (parsedArgs, sourceFile)=>{
    const storageListFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.storages${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const storageListFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, storageListFile);
    return (0, $kQNfl$fspromises.access)(storageListFilename).then(()=>{
        (0, $kQNfl$taquerianodesdk.sendWarn)(`Warning: The naming convention of "<CONTRACT>.storages.<EXTENSION>" is deprecated and renamed to "<CONTRACT>.storageList.<EXTENSION>". Please adjust your storage file names accordingly\n`);
        return $24b2f47d8f306cb3$var$compileExprs(parsedArgs, storageListFile, "storage");
    });
};
// TODO: Just for backwards compatibility. Can be deleted in the future.
const $24b2f47d8f306cb3$var$tryLegacyParameterNamingConvention = (parsedArgs, sourceFile)=>{
    const parameterListFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.parameters${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const parameterListFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, parameterListFile);
    return (0, $kQNfl$fspromises.access)(parameterListFilename).then(()=>{
        (0, $kQNfl$taquerianodesdk.sendWarn)(`Warning: The naming convention of "<CONTRACT>.parameters.<EXTENSION>" is deprecated and renamed to "<CONTRACT>.parameterList.<EXTENSION>". Please adjust your parameter file names accordingly\n`);
        return $24b2f47d8f306cb3$var$compileExprs(parsedArgs, parameterListFile, "parameter");
    });
};
const $24b2f47d8f306cb3$var$initContentForStorage = (sourceFile)=>{
    const linkToContract = `#include "${sourceFile}"\n\n`;
    const instruction = "// Define your initial storage values as a list of LIGO variable definitions,\n// the first of which will be considered the default value to be used for origination later on\n";
    const ext = $24b2f47d8f306cb3$var$extractExt(sourceFile);
    let syntax = "";
    if (ext === ".ligo") syntax = "// E.g. const aStorageValue : aStorageType = 10;\n\n";
    else if (ext === ".religo") syntax = "// E.g. let aStorageValue : aStorageType = 10;\n\n";
    else if (ext === ".mligo") syntax = "// E.g. let aStorageValue : aStorageType = 10\n\n";
    else if (ext === ".jsligo") syntax = "// E.g. const aStorageValue : aStorageType = 10;\n\n";
    return linkToContract + instruction + syntax;
};
const $24b2f47d8f306cb3$var$initContentForParameter = (sourceFile)=>{
    const linkToContract = `#include "${sourceFile}"\n\n`;
    const instruction = "// Define your parameter values as a list of LIGO variable definitions\n";
    const ext = $24b2f47d8f306cb3$var$extractExt(sourceFile);
    let syntax = "";
    if (ext === ".ligo") syntax = "// E.g. const aParameterValue : aParameterType = Increment(1);\n\n";
    else if (ext === ".religo") syntax = "// E.g. let aParameterValue : aParameterType = (Increment (1));\n\n";
    else if (ext === ".mligo") syntax = "// E.g. let aParameterValue : aParameterType = Increment 1\n\n";
    else if (ext === ".jsligo") syntax = "// E.g. const aParameterValue : aParameterType = (Increment (1));\n\n";
    return linkToContract + instruction + syntax;
};
const $24b2f47d8f306cb3$var$compileContractWithStorageAndParameter = async (parsedArgs, sourceFile)=>{
    const contractCompileResult = await $24b2f47d8f306cb3$var$compileContract(parsedArgs, sourceFile);
    if (contractCompileResult.artifact === $24b2f47d8f306cb3$var$COMPILE_ERR_MSG) return [
        contractCompileResult
    ];
    const storageListFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.storageList${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const storageListFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, storageListFile);
    const storageCompileResult = await (0, $kQNfl$fspromises.access)(storageListFilename).then(()=>$24b2f47d8f306cb3$var$compileExprs(parsedArgs, storageListFile, "storage")).catch(()=>$24b2f47d8f306cb3$var$tryLegacyStorageNamingConvention(parsedArgs, sourceFile)).catch(()=>{
        (0, $kQNfl$taquerianodesdk.sendWarn)(`Note: storage file associated with "${sourceFile}" can't be found, so "${storageListFile}" has been created for you. Use this file to define all initial storage values for this contract\n`);
        (0, $kQNfl$fspromises.writeFile)(storageListFilename, $24b2f47d8f306cb3$var$initContentForStorage(sourceFile), "utf8");
    });
    const parameterListFile = `${$24b2f47d8f306cb3$var$removeExt(sourceFile)}.parameterList${$24b2f47d8f306cb3$var$extractExt(sourceFile)}`;
    const parameterListFilename = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, parameterListFile);
    const parameterCompileResult = await (0, $kQNfl$fspromises.access)(parameterListFilename).then(()=>$24b2f47d8f306cb3$var$compileExprs(parsedArgs, parameterListFile, "parameter")).catch(()=>$24b2f47d8f306cb3$var$tryLegacyParameterNamingConvention(parsedArgs, sourceFile)).catch(()=>{
        (0, $kQNfl$taquerianodesdk.sendWarn)(`Note: parameter file associated with "${sourceFile}" can't be found, so "${parameterListFile}" has been created for you. Use this file to define all parameter values for this contract\n`);
        (0, $kQNfl$fspromises.writeFile)(parameterListFilename, $24b2f47d8f306cb3$var$initContentForParameter(sourceFile), "utf8");
    });
    let compileResults = [
        contractCompileResult
    ];
    if (storageCompileResult) compileResults = compileResults.concat(storageCompileResult);
    if (parameterCompileResult) compileResults = compileResults.concat(parameterCompileResult);
    return compileResults;
};
/*
Compiling storage/parameter file amounts to compiling multiple expressions in that file,
resulting in multiple rows with the same file name but different artifact names.
This will merge these rows into one row with just one mention of the file name.
e.g.
┌─────────────────────────┬─────────────────────────────────────────────┐
│ Contract                │ Artifact                                    │
├─────────────────────────┼─────────────────────────────────────────────┤
│ hello.storageList.mligo │ artifacts/hello.default_storage.storage1.tz │
├─────────────────────────┼─────────────────────────────────────────────┤
│ hello.storageList.mligo │ artifacts/hello.storage.storage2.tz         │
└─────────────────────────┴─────────────────────────────────────────────┘
								versus
┌─────────────────────────┬─────────────────────────────────────────────┐
│ Contract                │ Artifact                                    │
├─────────────────────────┼─────────────────────────────────────────────┤
│ hello.storageList.mligo │ artifacts/hello.default_storage.storage1.tz │
│                         │ artifacts/hello.storage.storage2.tz         │
└─────────────────────────┴─────────────────────────────────────────────┘
*/ const $24b2f47d8f306cb3$var$mergeArtifactsOutput = (sourceFile)=>(tableRows)=>{
        const artifactsOutput = tableRows.reduce((acc, row)=>row.artifact === $24b2f47d8f306cb3$var$COMPILE_ERR_MSG ? acc : `${acc}${row.artifact}\n`, "");
        return [
            {
                contract: sourceFile,
                artifact: artifactsOutput
            }
        ];
    };
const $24b2f47d8f306cb3$var$compile = (parsedArgs)=>{
    const sourceFile = parsedArgs.sourceFile;
    let p;
    if ($24b2f47d8f306cb3$var$isStorageListFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileExprs(parsedArgs, sourceFile, "storage");
    else if ($24b2f47d8f306cb3$var$isParameterListFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileExprs(parsedArgs, sourceFile, "parameter");
    else if ($24b2f47d8f306cb3$var$isContractFile(sourceFile)) p = $24b2f47d8f306cb3$var$compileContractWithStorageAndParameter(parsedArgs, sourceFile);
    else return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`${sourceFile} doesn't have a valid LIGO extension ('.ligo', '.religo', '.mligo' or '.jsligo')`);
    return p.then((0, $kQNfl$taquerianodesdk.sendJsonRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $24b2f47d8f306cb3$export$2e2bcd8739ae039 = $24b2f47d8f306cb3$var$compile;




const $0be740342372c80a$var$getArbitraryLigoCmd = (parsedArgs, userArgs)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const binary = "docker";
    const baseArgs = [
        "run",
        "--rm",
        "-v",
        `${projectDir}:/project`,
        "-w",
        "/project",
        (0, $844cb58d66fbf6db$export$2b403d61ac8ea302)()
    ];
    const processedUserArgs = userArgs.split(" ").map((arg)=>arg.startsWith("\\-") ? arg.substring(1) : arg).filter((arg)=>arg);
    const args = baseArgs.concat(processedUserArgs);
    const envVars = {
        "DOCKER_DEFAULT_PLATFORM": "linux/amd64"
    };
    return [
        binary,
        args,
        envVars
    ];
};
const $0be740342372c80a$var$runArbitraryLigoCmd = (parsedArgs, cmd)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$0be740342372c80a$var$getArbitraryLigoCmd(parsedArgs, cmd)).then((0, $kQNfl$taquerianodesdk.spawnCmd)).then((code)=>code !== null && code === 0 ? `Command "${cmd}" ran successfully by LIGO` : `Command "${cmd}" failed. Please check your command`).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(`An internal error has occurred: ${err.message}`));
const $0be740342372c80a$var$ligo = (parsedArgs)=>{
    const args = parsedArgs.command;
    return $0be740342372c80a$var$runArbitraryLigoCmd(parsedArgs, args).then((0, $kQNfl$taquerianodesdk.sendRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $0be740342372c80a$export$2e2bcd8739ae039 = $0be740342372c80a$var$ligo;




const $8d09eb70c0505719$var$getTestContractCmd = (parsedArgs, sourceFile)=>{
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir) throw `No project directory provided`;
    const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ${(0, $844cb58d66fbf6db$export$2b403d61ac8ea302)()} run test`;
    const inputFile = (0, $844cb58d66fbf6db$export$17f107107c3c82c6)(parsedArgs, sourceFile);
    const cmd = `${baseCmd} ${inputFile}`;
    return cmd;
};
const $8d09eb70c0505719$var$testContract = (parsedArgs, sourceFile)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$8d09eb70c0505719$var$getTestContractCmd(parsedArgs, sourceFile)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stdout: stdout , stderr: stderr  })=>{
        if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendWarn)(stderr);
        const result = "\uD83C\uDF89 All tests passed \uD83C\uDF89";
        return {
            contract: sourceFile,
            testResults: stdout.length > 0 ? `${stdout}\n${result}` : result
        };
    }).catch((err)=>{
        (0, $844cb58d66fbf6db$export$b59ff90dc389ce6d)(err, sourceFile);
        return {
            contract: sourceFile,
            testResults: "Some tests failed :("
        };
    });
const $8d09eb70c0505719$var$test = (parsedArgs)=>{
    const sourceFile = parsedArgs.sourceFile;
    return $8d09eb70c0505719$var$testContract(parsedArgs, sourceFile).then((result)=>[
            result
        ]).then((0, $kQNfl$taquerianodesdk.sendJsonRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $8d09eb70c0505719$export$2e2bcd8739ae039 = $8d09eb70c0505719$var$test;


const $9c25a106900e330c$var$main = (parsedArgs)=>{
    switch(parsedArgs.task){
        case "ligo":
            return (0, $0be740342372c80a$export$2e2bcd8739ae039)(parsedArgs);
        case "compile":
            return (0, $24b2f47d8f306cb3$export$2e2bcd8739ae039)(parsedArgs);
        case "test":
            return (0, $8d09eb70c0505719$export$2e2bcd8739ae039)(parsedArgs);
        case "get-image":
            return (0, $kQNfl$taquerianodesdk.sendAsyncRes)((0, $844cb58d66fbf6db$export$2b403d61ac8ea302)());
        default:
            return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`${parsedArgs.task} is not an understood task by the LIGO plugin`);
    }
};
var $9c25a106900e330c$export$2e2bcd8739ae039 = $9c25a106900e330c$var$main;


(0, $kQNfl$taquerianodesdk.Plugin).create((i18n)=>({
        schema: "1.0",
        version: "0.1",
        alias: "ligo",
        tasks: [
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "ligo",
                command: "ligo",
                description: "This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria",
                options: [
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "c",
                        flag: "command",
                        type: "string",
                        description: "The command to be passed to the underlying LIGO binary, wrapped in quotes",
                        required: true
                    }), 
                ],
                handler: "proxy",
                encoding: "none"
            }),
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "compile",
                command: "compile <sourceFile>",
                aliases: [
                    "c",
                    "compile-ligo"
                ],
                description: "Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found",
                handler: "proxy",
                encoding: "json"
            }),
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "test",
                command: "test <sourceFile>",
                description: "Test a smart contract written in LIGO",
                handler: "proxy",
                encoding: "json"
            }),
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "get-image",
                command: "get-image",
                description: "Gets the name of the image to be used",
                handler: "proxy",
                hidden: true
            }), 
        ],
        templates: [
            (0, $kQNfl$taquerianodesdk.Template).create({
                template: "contract",
                command: "contract <sourceFileName>",
                description: "Create a LIGO contract with boilerplate code",
                positionals: [
                    (0, $kQNfl$taquerianodesdk.PositionalArg).create({
                        placeholder: "sourceFileName",
                        type: "string",
                        description: "The name of the LIGO contract to generate"
                    }), 
                ],
                options: [
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "s",
                        flag: "syntax",
                        type: "string",
                        description: "The syntax used in the contract"
                    }), 
                ],
                handler: (0, $40622e3a438d0515$export$2e2bcd8739ae039)
            }), 
        ],
        proxy: (0, $9c25a106900e330c$export$2e2bcd8739ae039)
    }), process.argv);


//# sourceMappingURL=index.js.map
