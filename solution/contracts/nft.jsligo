#import "@ligo/fa/lib/fa2/asset/single_asset.mligo" "SINGLEASSET"


/* ERROR MAP FOR UI DISPLAY or TESTS
    const errorMap : map<string,string> = Map.literal(list([
      ["0", "Enter a positive and not null amount"],
      ["1", "Operation not allowed, you need to be administrator"],
      ["2", "You cannot sell more than your current balance"],
      ["3", "Cannot find the offer you entered for buying"],
      ["4", "You entered a quantity to buy than is more than the offer quantity"],
      ["5", "Not enough funds, you need to pay at least quantity * price to get the tokens"],
      ["6", "Cannot find the contract relative to implicit address"],
    ]));
*/

type offer = {
  quantity : nat,
  price : nat
};

type storage =
  {
    administrators: set<address>,
    totalSupply: nat,
    offers: map<address,offer>,  //user sells an offer
    ledger: SINGLEASSET.Ledger.t,
    metadata: SINGLEASSET.Metadata.t,
    token_metadata: SINGLEASSET.TokenMetadata.t,
    operators: SINGLEASSET.Operators.t,
    owners: set<SINGLEASSET.Storage.owner>
  };

type ret = [list<operation>, storage];

type parameter =
  | ["Mint", nat,bytes,bytes,bytes,bytes] // quantity, name , description ,symbol , bytesipfsUrl 
  | ["AddAdministrator" , address]  
  | ["Buy", nat, address]  //buy quantity at a seller offer price
  | ["Sell", nat, nat]  //sell quantity at a price
  | ["Transfer", SINGLEASSET.transfer]
  | ["Balance_of", SINGLEASSET.balance_of]
  | ["Update_operators", SINGLEASSET.update_operators];


const mint = (quantity:nat, name :bytes, description:bytes ,symbol:bytes , ipfsUrl:bytes, s : storage) : ret => {
   
   if(quantity <= (0 as nat)) return failwith("0");
   
   if(! Set.mem(Tezos.get_sender(), s.administrators)) return failwith("1");
   
    const token_info: map<string, bytes> = 
     Map.literal(list([
      ["name", name],
      ["description",description],
      ["interfaces", (bytes `["TZIP-12"]`)],
      ["thumbnailUri", ipfsUrl],
      ["symbol",symbol],
      ["decimals", (bytes `0`)]
     ])) as map<string, bytes>;


    const metadata : bytes = bytes
  `{
      "name":"FA2 NFT Marketplace",
      "description":"Example of FA2 implementation",
      "version":"0.0.1",
      "license":{"name":"MIT"},
      "authors":["Marigold<contact@marigold.dev>"],
      "homepage":"https://marigold.dev",
      "source":{
        "tools":["Ligo"],
        "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
      "interfaces":["TZIP-012"],
      "errors": [],
      "views": []
      }` ;

    return [list([]) as list<operation>,
          {...s,
     totalSupply: quantity,
     ledger: Big_map.literal(list([[Tezos.get_sender(),quantity as nat]])) as SINGLEASSET.Ledger.t,
     metadata : Big_map.literal(list([["",  bytes `tezos-storage:data`],["data", metadata]])),
     token_metadata: Big_map.add(0 as nat, {token_id: 0 as nat,token_info:token_info},s.token_metadata),
     operators: Big_map.empty as SINGLEASSET.Operators.t,
     owners: Set.add(Tezos.get_sender(),s.owners)}];
     };


const sell = (quantity: nat, price: nat, s: storage) : ret => {

  //check balance of seller
  const sellerBalance = SINGLEASSET.Storage.get_amount_for_owner({ledger:s.ledger,metadata:s.metadata,operators:s.operators,token_metadata:s.token_metadata,owners:s.owners})(Tezos.get_source());
  if(quantity > sellerBalance) return failwith("2");

  //need to allow the contract itself to be an operator on behalf of the seller
  const newOperators = SINGLEASSET.Operators.add_operator(s.operators)(Tezos.get_source())(Tezos.get_self_address()); 

  //DECISION CHOICE: if offer already exists, we just override it
  return [list([]) as list<operation>,{...s,offers:Map.add(Tezos.get_source(),{quantity : quantity, price : price},s.offers),operators:newOperators}];
};


const buy = (quantity: nat, seller: address, s: storage) : ret => {

  //search for the offer
  return match( Map.find_opt(seller,s.offers) , {
    None : () => failwith("3"),
    Some : (offer : offer) => {
      //check if quantity is enough
      if(quantity > offer.quantity) return failwith("4");
      //check if amount have been paid enough
      if(Tezos.get_amount() < (offer.price * quantity) * (1 as mutez)) return failwith("5");
      
      // prepare transfer of XTZ to seller
      const op = Tezos.transaction(unit,(offer.price * quantity) * (1 as mutez),Tezos.get_contract_with_error(seller,"6"));

      //transfer tokens from seller to buyer
      let ledger = SINGLEASSET.Ledger.decrease_token_amount_for_user(s.ledger)(seller)(quantity);
      ledger = SINGLEASSET.Ledger.increase_token_amount_for_user(ledger)(Tezos.get_source())(quantity);

      //update new offer
      const newOffer = {...offer,quantity : abs(offer.quantity - quantity)};

      return [list([op]) as list<operation>, {...s, offers : Map.update(seller,Some(newOffer),s.offers), ledger : ledger, owners : Set.add(Tezos.get_source(),s.owners)}];
    }
  }); 
};

const main = ([p, s]: [parameter,storage]): ret => 
    match(p, {
     Mint: (p: [nat,bytes,bytes,bytes,bytes]) => mint(p[0],p[1],p[2],p[3],p[4],s),
     AddAdministrator : (p : address) => {if(Set.mem(Tezos.get_sender(), s.administrators)){ return [list([]),{...s,administrators:Set.add(p, s.administrators)}]} else {return failwith("1");}} ,
     Buy: (p : [nat,address]) => buy(p[0],p[1],s),
     Sell: (p : [nat,nat]) => sell(p[0],p[1], s),
     Transfer: (p: SINGLEASSET.transfer) => {
      const ret2 : [list<operation>, SINGLEASSET.storage] = SINGLEASSET.transfer(p)({ledger:s.ledger,metadata:s.metadata,token_metadata:s.token_metadata,operators:s.operators,owners:s.owners});
      return [ret2[0],{...s,ledger:ret2[1].ledger,metadata:ret2[1].metadata,token_metadata:ret2[1].token_metadata,operators:ret2[1].operators,owners:ret2[1].owners}];
     },
     Balance_of: (p: SINGLEASSET.balance_of) => {
      const ret2 : [list<operation>, SINGLEASSET.storage] = SINGLEASSET.balance_of(p)({ledger:s.ledger,metadata:s.metadata,token_metadata:s.token_metadata,operators:s.operators,owners:s.owners});
      return [ret2[0],{...s,ledger:ret2[1].ledger,metadata:ret2[1].metadata,token_metadata:ret2[1].token_metadata,operators:ret2[1].operators,owners:ret2[1].owners}];
      },
     Update_operators: (p: SINGLEASSET.update_operator) => {
      const ret2 : [list<operation>, SINGLEASSET.storage] = SINGLEASSET.update_ops(p)({ledger:s.ledger,metadata:s.metadata,token_metadata:s.token_metadata,operators:s.operators,owners:s.owners});
      return [ret2[0],{...s,ledger:ret2[1].ledger,metadata:ret2[1].metadata,token_metadata:ret2[1].token_metadata,operators:ret2[1].operators,owners:ret2[1].owners}];
      }
     });